Q1. ImplÃ©mentation dâ€™un graphe hexagonal

Une grille hexagonale peut Ãªtre modÃ©lisÃ©e comme un graphe non orientÃ© :

Chaque case hexagonale correspond Ã  un sommet

Une arÃªte relie deux sommets si les cases sont voisines

Chaque sommet possÃ¨de jusquâ€™Ã  6 voisins (sauf aux bords)

Le graphe est :

connexe

non orientÃ©

non pondÃ©rÃ© (dans la version de base)

Les coordonnÃ©es (x, y) permettent dâ€™identifier de maniÃ¨re unique chaque sommet et de calculer ses voisins grÃ¢ce aux rÃ¨gles de voisinage hexagonal.

Q2. Extension : terrain et altitude

On peut enrichir les sommets avec des labels :

Type de terrain : herbe, montagne, eau, route, etc.

Altitude : valeur numÃ©rique (entier ou rÃ©el)

Chaque sommet contient donc :

ses coordonnÃ©es

son altitude

son type de terrain

Le type de terrain peut Ãªtre dÃ©duit automatiquement de lâ€™altitude (par seuils) ou assignÃ© indÃ©pendamment.

Q3. Tests avec gÃ©nÃ©ration alÃ©atoire

Pour tester le programme :

Les altitudes sont gÃ©nÃ©rÃ©es alÃ©atoirement dans un intervalle donnÃ©

Les terrains sont assignÃ©s soit alÃ©atoirement, soit en fonction de lâ€™altitude

Lâ€™affichage utilise :

les couleurs pour reprÃ©senter les terrains

la transparence pour reprÃ©senter lâ€™altitude

Cela permet de vÃ©rifier visuellement la cohÃ©rence de la carte gÃ©nÃ©rÃ©e.

Q4. GÃ©nÃ©ration dâ€™une zone rÃ©guliÃ¨re
Algorithme utilisÃ©

ğŸ‘‰ BFS (Breadth-First Search)

Principe

On part dâ€™une case source

On explore le graphe par couches successives

Toutes les cases visitÃ©es Ã  la couche i sont Ã  distance i

Adaptation

On stocke la distance depuis la source

On sâ€™arrÃªte lorsque la distance maximale est atteinte

Cet algorithme est parfaitement adaptÃ© pour gÃ©nÃ©rer des zones concentriques rÃ©guliÃ¨res.

Q5.a Trouver le sommet le plus haut

Il suffit de :

parcourir tous les sommets

comparer leurs altitudes

conserver celui dont lâ€™altitude est maximale

ComplexitÃ©

O(n) avec n le nombre de sommets

Q5.b GÃ©nÃ©ration de riviÃ¨res
Algorithme utilisÃ©

ğŸ‘‰ DFS (Depth-First Search)

Principe

On part dâ€™un sommet source (altitude Ã©levÃ©e)

Ã€ chaque Ã©tape, on se dÃ©place vers un voisin dâ€™altitude strictement infÃ©rieure

DFS permet dâ€™explorer un chemin en profondeur pour obtenir une riviÃ¨re longue

DFS est bien adaptÃ© pour modÃ©liser un Ã©coulement naturel.

Q5.c Embranchements de riviÃ¨res

Pour crÃ©er des embranchements :

on explore plusieurs voisins valides au lieu dâ€™un seul

Structure obtenue

un arbre orientÃ©

ou plus gÃ©nÃ©ralement un graphe orientÃ© acyclique (DAG)

Cela modÃ©lise un rÃ©seau hydrographique rÃ©aliste.

Q6. GÃ©nÃ©ration complÃ¨te dâ€™une carte cohÃ©rente
Algorithme proposÃ©

ğŸ‘‰ Diamond-Square Algorithm

Ã‰tapes gÃ©nÃ©rales

GÃ©nÃ©ration des altitudes avec Diamond-Square

Attribution des terrains selon lâ€™altitude

Identification des sommets Ã©levÃ©s

GÃ©nÃ©ration des riviÃ¨res par DFS

Cette approche permet dâ€™obtenir des altitudes progressives et des terrains cohÃ©rents.

Extension bonus : lacs
Contrainte ajoutÃ©e

Lâ€™eau nâ€™est plus uniquement linÃ©aire

Elle peut former des zones fermÃ©es

Solution

DÃ©tection de minima locaux

Accumulation de lâ€™eau dans les bassins

Gestion de dÃ©bordement Ã©ventuel

Q7. GÃ©nÃ©ration de routes rapides entre villes
Algorithme utilisÃ©

ğŸ‘‰ Dijkstra

Justification

Les routes doivent minimiser la distance (ou le temps)

Le graphe est pondÃ©rÃ© uniformÃ©ment (sans contraintes terrain)

ComplexitÃ©

O((V + E) log V) avec une file de prioritÃ©

Analyse expÃ©rimentale

Le temps de calcul augmente avec :

la taille de la grille

le nombre de villes

Les rÃ©sultats peuvent Ãªtre comparÃ©s via un graphique temps / taille

Q8. Prise en compte du terrain et de lâ€™altitude
Modifications

PondÃ©rer les arÃªtes selon :

le type de terrain

la diffÃ©rence dâ€™altitude

Supprimer ou interdire les arÃªtes passant par lâ€™eau

Effets

Les chemins deviennent plus longs mais plus rÃ©alistes

Certains trajets deviennent impossibles

Q9. RÃ©seau de routes minimal
Algorithme utilisÃ©

ğŸ‘‰ Arbre couvrant de poids minimal

Kruskal ou Prim

Objectif

Relier toutes les villes

Minimiser le coÃ»t total

Respecter les contraintes terrain / eau

Le rÃ©sultat est un rÃ©seau minimal connexe.

Q10. Parcours optimal dâ€™un marchand
ProblÃ¨me modÃ©lisÃ©

ğŸ‘‰ ProblÃ¨me du voyageur de commerce (TSP)

Solutions possibles

Heuristiques gloutonnes

Recherche locale

Algorithmes approchÃ©s

Le marchand visite toutes les villes et revient au point de dÃ©part avec un coÃ»t minimal.

Extension bonus : autres transports

Ajouter des couches de graphes

routes (terre)

voies maritimes

liaisons aÃ©riennes

Modifier les poids et contraintes selon le mode de transport